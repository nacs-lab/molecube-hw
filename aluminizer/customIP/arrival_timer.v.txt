`timescale 1ns / 1ps

/* 
Photon arrival time counter.  

Pushes photon arrival times into a FIFO buffer.
Timer is reset on sync inout.
Packs results into 64-bit wide FIFO.
Till Rosenband 1/25/2011
*/

module arrival_timer(clock, reset, gate, sync, photon, rFIFO_data, rFIFO_WrReq, rFIFO_WrAck, rFIFO_full);

parameter ARRIVAL_BITS 	= 16;
parameter rFIFO_WIDTH 	= 64;
 
input  clock;
input  reset;
input  gate;
input  sync;
input  photon;

output [0:(rFIFO_WIDTH-1)] rFIFO_data;
output rFIFO_WrReq;
input rFIFO_WrAck;
input rFIFO_full;


reg photon_r;
reg sync_r;
reg new_photon;
reg [0:3] num_photons;
reg [0:(ARRIVAL_BITS-1)] timer;
reg [0:(ARRIVAL_BITS-1)] timer2;
reg [0:(rFIFO_WIDTH-1)] rFIFO_data_reg;

assign rFIFO_WrReq = wrreq_r;
assign rFIFO_data = rFIFO_data_reg; 

wire gated_photon_in;
assign gated_photon_in = photon & gate;

always @(posedge sync)
begin
	
	timer <= 1
end

//latch photon and sync signals into registers so they don't change at a weird time
always @(posedge clock) begin
	photon_r <= photon;
	sync_r <= sync;
	not_sync_r <= ~sync;
end

always @(posedge sync_r) begin
	reset_timer = 1;
end

always @(posedge clock)
begin
 if(reset_timer) begin
	timer <= 1;
 end else begin
	timer <= timer+1;
end

always @(posedge clock and posedge not_sync_r)
begin
	
	timer <= timer+1
end

reg [0:1] fifo_write_state;
reg result_WrReq_reg;

always @(posedge clock) begin
	if(reset) begin
		rFIFO_data_reg <= 0;
		num_photons <= 0;
		new_photon <= 0;
	end else begin
		if(wreq_r) begin
			wreq_r <= 0;
		end

		if(sync_r) begin
			timer <= 0;
		end else begin
			timer <= timer+1;
			if(gate & photon_r) begin
				timer2 <= timer;
				new_photon <= 1;
				num_photons <= num_photons + 1;
			end
		end

		if(new_photon && fifo_write_state==0) begin
			for(i=0; i<(rFIFO_WIDTH/ARRIVAL_BITS); i = i+1)
				if(num_photons == i) begin
					rFIFO_data_reg[(i*ARRIVAL_BITS):((i+1)*ARRIVAL_BITS-1)] = timer2;
				end
			end
	
			new_photon <= 0
	
			if(num_photons == MAX_NUM_PHOTONS) begin
				num_photons <= 0;
				fifo_write_state <= 1;
			end
		end
	
	end
end

always @(posedge clock or posedge reset)
begin
	if(reset) begin
		result_WrReq_reg <= 0;
		fifo_write_state <= 0;
	end else begin		
		case(fifo_write_state)	
			1: begin 
					result_WrReq_reg <= 1;
					fifo_write_state <= 2;
				end
				
			2: if(result_WrAck == 1) begin //wait for WrAck
					result_WrReq_reg <= 0;
					fifo_write_state <= 3;
				end
				
			3: fifo_write_state <= 0;
		endcase
	end
end	

endmodule
